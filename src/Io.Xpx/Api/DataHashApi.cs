/* 
 * Proximax P2P Storage REST API
 *
 * Proximax P2P Storage REST API
 *
 * OpenAPI spec version: v0.0.1
 * Contact: alvin.reyes@botmill.io
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Io.Xpx.Client;
using Io.Xpx.Model;

namespace Io.Xpx.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IDataHashApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Calls the garbage clean up and tries to unpin the given hash
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="multihash">The pinned multihash</param>
        /// <returns>string</returns>
        string CleanupPinnedContentUsingPOST (string multihash);

        /// <summary>
        /// Calls the garbage clean up and tries to unpin the given hash
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="multihash">The pinned multihash</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> CleanupPinnedContentUsingPOSTWithHttpInfo (string multihash);
        /// <summary>
        /// Generates the encrypted datahash and uploads the JSON Format String data to the P2P Storage Network.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network</param>
        /// <param name="name">Custom Name of the data. If none is specified, timestamp will be used. (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>BinaryTransactionEncryptedMessage</returns>
        BinaryTransactionEncryptedMessage GenerateHashAndExposeDataToNetworkUsingPOST (string data, string name = null, string keywords = null, string metadata = null);

        /// <summary>
        /// Generates the encrypted datahash and uploads the JSON Format String data to the P2P Storage Network.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network</param>
        /// <param name="name">Custom Name of the data. If none is specified, timestamp will be used. (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>ApiResponse of BinaryTransactionEncryptedMessage</returns>
        ApiResponse<BinaryTransactionEncryptedMessage> GenerateHashAndExposeDataToNetworkUsingPOSTWithHttpInfo (string data, string name = null, string keywords = null, string metadata = null);
        /// <summary>
        /// Generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>BinaryTransactionEncryptedMessage</returns>
        BinaryTransactionEncryptedMessage GenerateHashAndExposeFileToNetworkUsingPOST (System.IO.Stream file, string keywords = null, string metadata = null);

        /// <summary>
        /// Generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>ApiResponse of BinaryTransactionEncryptedMessage</returns>
        ApiResponse<BinaryTransactionEncryptedMessage> GenerateHashAndExposeFileToNetworkUsingPOSTWithHttpInfo (System.IO.Stream file, string keywords = null, string metadata = null);
        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>RequestAnnounceDataSignature</returns>
        RequestAnnounceDataSignature GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOST (string xPvkey = null, string xPubkey = null, string messageType = null, string data = null, string keywords = null, string metadata = null);

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>ApiResponse of RequestAnnounceDataSignature</returns>
        ApiResponse<RequestAnnounceDataSignature> GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOSTWithHttpInfo (string xPvkey = null, string xPubkey = null, string messageType = null, string data = null, string keywords = null, string metadata = null);
        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="file">The Multipart File (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>RequestAnnounceDataSignature</returns>
        RequestAnnounceDataSignature GenerateHashExposeFileToNetworkBuildAndSignUsingPOST (string xPvkey = null, string xPubkey = null, string messageType = null, System.IO.Stream file = null, string keywords = null, string metadata = null);

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="file">The Multipart File (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>ApiResponse of RequestAnnounceDataSignature</returns>
        ApiResponse<RequestAnnounceDataSignature> GenerateHashExposeFileToNetworkBuildAndSignUsingPOSTWithHttpInfo (string xPvkey = null, string xPubkey = null, string messageType = null, System.IO.Stream file = null, string keywords = null, string metadata = null);
        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>BinaryTransactionEncryptedMessage</returns>
        BinaryTransactionEncryptedMessage GenerateHashForDataOnlyUsingPOST (string data = null, string keywords = null, string metadata = null);

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>ApiResponse of BinaryTransactionEncryptedMessage</returns>
        ApiResponse<BinaryTransactionEncryptedMessage> GenerateHashForDataOnlyUsingPOSTWithHttpInfo (string data = null, string keywords = null, string metadata = null);
        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>BinaryTransactionEncryptedMessage</returns>
        BinaryTransactionEncryptedMessage GenerateHashForFileOnlyUsingPOST (System.IO.Stream file, string keywords = null, string metadata = null);

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>ApiResponse of BinaryTransactionEncryptedMessage</returns>
        ApiResponse<BinaryTransactionEncryptedMessage> GenerateHashForFileOnlyUsingPOSTWithHttpInfo (System.IO.Stream file, string keywords = null, string metadata = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Calls the garbage clean up and tries to unpin the given hash
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="multihash">The pinned multihash</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> CleanupPinnedContentUsingPOSTAsync (string multihash);

        /// <summary>
        /// Calls the garbage clean up and tries to unpin the given hash
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="multihash">The pinned multihash</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> CleanupPinnedContentUsingPOSTAsyncWithHttpInfo (string multihash);
        /// <summary>
        /// Generates the encrypted datahash and uploads the JSON Format String data to the P2P Storage Network.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network</param>
        /// <param name="name">Custom Name of the data. If none is specified, timestamp will be used. (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of BinaryTransactionEncryptedMessage</returns>
        System.Threading.Tasks.Task<BinaryTransactionEncryptedMessage> GenerateHashAndExposeDataToNetworkUsingPOSTAsync (string data, string name = null, string keywords = null, string metadata = null);

        /// <summary>
        /// Generates the encrypted datahash and uploads the JSON Format String data to the P2P Storage Network.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network</param>
        /// <param name="name">Custom Name of the data. If none is specified, timestamp will be used. (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of ApiResponse (BinaryTransactionEncryptedMessage)</returns>
        System.Threading.Tasks.Task<ApiResponse<BinaryTransactionEncryptedMessage>> GenerateHashAndExposeDataToNetworkUsingPOSTAsyncWithHttpInfo (string data, string name = null, string keywords = null, string metadata = null);
        /// <summary>
        /// Generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of BinaryTransactionEncryptedMessage</returns>
        System.Threading.Tasks.Task<BinaryTransactionEncryptedMessage> GenerateHashAndExposeFileToNetworkUsingPOSTAsync (System.IO.Stream file, string keywords = null, string metadata = null);

        /// <summary>
        /// Generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of ApiResponse (BinaryTransactionEncryptedMessage)</returns>
        System.Threading.Tasks.Task<ApiResponse<BinaryTransactionEncryptedMessage>> GenerateHashAndExposeFileToNetworkUsingPOSTAsyncWithHttpInfo (System.IO.Stream file, string keywords = null, string metadata = null);
        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>Task of RequestAnnounceDataSignature</returns>
        System.Threading.Tasks.Task<RequestAnnounceDataSignature> GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOSTAsync (string xPvkey = null, string xPubkey = null, string messageType = null, string data = null, string keywords = null, string metadata = null);

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>Task of ApiResponse (RequestAnnounceDataSignature)</returns>
        System.Threading.Tasks.Task<ApiResponse<RequestAnnounceDataSignature>> GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOSTAsyncWithHttpInfo (string xPvkey = null, string xPubkey = null, string messageType = null, string data = null, string keywords = null, string metadata = null);
        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="file">The Multipart File (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>Task of RequestAnnounceDataSignature</returns>
        System.Threading.Tasks.Task<RequestAnnounceDataSignature> GenerateHashExposeFileToNetworkBuildAndSignUsingPOSTAsync (string xPvkey = null, string xPubkey = null, string messageType = null, System.IO.Stream file = null, string keywords = null, string metadata = null);

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature.
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="file">The Multipart File (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>Task of ApiResponse (RequestAnnounceDataSignature)</returns>
        System.Threading.Tasks.Task<ApiResponse<RequestAnnounceDataSignature>> GenerateHashExposeFileToNetworkBuildAndSignUsingPOSTAsyncWithHttpInfo (string xPvkey = null, string xPubkey = null, string messageType = null, System.IO.Stream file = null, string keywords = null, string metadata = null);
        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of BinaryTransactionEncryptedMessage</returns>
        System.Threading.Tasks.Task<BinaryTransactionEncryptedMessage> GenerateHashForDataOnlyUsingPOSTAsync (string data = null, string keywords = null, string metadata = null);

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of ApiResponse (BinaryTransactionEncryptedMessage)</returns>
        System.Threading.Tasks.Task<ApiResponse<BinaryTransactionEncryptedMessage>> GenerateHashForDataOnlyUsingPOSTAsyncWithHttpInfo (string data = null, string keywords = null, string metadata = null);
        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of BinaryTransactionEncryptedMessage</returns>
        System.Threading.Tasks.Task<BinaryTransactionEncryptedMessage> GenerateHashForFileOnlyUsingPOSTAsync (System.IO.Stream file, string keywords = null, string metadata = null);

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file.
        /// </summary>
        /// <remarks>
        /// This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </remarks>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of ApiResponse (BinaryTransactionEncryptedMessage)</returns>
        System.Threading.Tasks.Task<ApiResponse<BinaryTransactionEncryptedMessage>> GenerateHashForFileOnlyUsingPOSTAsyncWithHttpInfo (System.IO.Stream file, string keywords = null, string metadata = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class DataHashApi : IDataHashApi
    {
        private Io.Xpx.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="DataHashApi"/> class.
        /// </summary>
        /// <returns></returns>
        public DataHashApi(String basePath)
        {
            this.Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = Io.Xpx.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DataHashApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public DataHashApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Io.Xpx.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Io.Xpx.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<String, String> DefaultHeader()
        {
            return this.Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Calls the garbage clean up and tries to unpin the given hash This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="multihash">The pinned multihash</param>
        /// <returns>string</returns>
        public string CleanupPinnedContentUsingPOST (string multihash)
        {
             ApiResponse<string> localVarResponse = CleanupPinnedContentUsingPOSTWithHttpInfo(multihash);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Calls the garbage clean up and tries to unpin the given hash This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="multihash">The pinned multihash</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > CleanupPinnedContentUsingPOSTWithHttpInfo (string multihash)
        {
            // verify the required parameter 'multihash' is set
            if (multihash == null)
                throw new ApiException(400, "Missing required parameter 'multihash' when calling DataHashApi->CleanupPinnedContentUsingPOST");

            var localVarPath = "/datahash/cleanup";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (multihash != null) localVarQueryParams.Add("multihash", Configuration.ApiClient.ParameterToString(multihash)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CleanupPinnedContentUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Calls the garbage clean up and tries to unpin the given hash This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="multihash">The pinned multihash</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> CleanupPinnedContentUsingPOSTAsync (string multihash)
        {
             ApiResponse<string> localVarResponse = await CleanupPinnedContentUsingPOSTAsyncWithHttpInfo(multihash);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Calls the garbage clean up and tries to unpin the given hash This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="multihash">The pinned multihash</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> CleanupPinnedContentUsingPOSTAsyncWithHttpInfo (string multihash)
        {
            // verify the required parameter 'multihash' is set
            if (multihash == null)
                throw new ApiException(400, "Missing required parameter 'multihash' when calling DataHashApi->CleanupPinnedContentUsingPOST");

            var localVarPath = "/datahash/cleanup";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (multihash != null) localVarQueryParams.Add("multihash", Configuration.ApiClient.ParameterToString(multihash)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CleanupPinnedContentUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Generates the encrypted datahash and uploads the JSON Format String data to the P2P Storage Network. This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network</param>
        /// <param name="name">Custom Name of the data. If none is specified, timestamp will be used. (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>BinaryTransactionEncryptedMessage</returns>
        public BinaryTransactionEncryptedMessage GenerateHashAndExposeDataToNetworkUsingPOST (string data, string name = null, string keywords = null, string metadata = null)
        {
             ApiResponse<BinaryTransactionEncryptedMessage> localVarResponse = GenerateHashAndExposeDataToNetworkUsingPOSTWithHttpInfo(data, name, keywords, metadata);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Generates the encrypted datahash and uploads the JSON Format String data to the P2P Storage Network. This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network</param>
        /// <param name="name">Custom Name of the data. If none is specified, timestamp will be used. (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>ApiResponse of BinaryTransactionEncryptedMessage</returns>
        public ApiResponse< BinaryTransactionEncryptedMessage > GenerateHashAndExposeDataToNetworkUsingPOSTWithHttpInfo (string data, string name = null, string keywords = null, string metadata = null)
        {
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling DataHashApi->GenerateHashAndExposeDataToNetworkUsingPOST");

            var localVarPath = "/datahash/upload/data/generate";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null) localVarQueryParams.Add("data", Configuration.ApiClient.ParameterToString(data)); // query parameter
            if (name != null) localVarQueryParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // query parameter
            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashAndExposeDataToNetworkUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BinaryTransactionEncryptedMessage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (BinaryTransactionEncryptedMessage) Configuration.ApiClient.Deserialize(localVarResponse, typeof(BinaryTransactionEncryptedMessage)));
        }

        /// <summary>
        /// Generates the encrypted datahash and uploads the JSON Format String data to the P2P Storage Network. This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network</param>
        /// <param name="name">Custom Name of the data. If none is specified, timestamp will be used. (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of BinaryTransactionEncryptedMessage</returns>
        public async System.Threading.Tasks.Task<BinaryTransactionEncryptedMessage> GenerateHashAndExposeDataToNetworkUsingPOSTAsync (string data, string name = null, string keywords = null, string metadata = null)
        {
             ApiResponse<BinaryTransactionEncryptedMessage> localVarResponse = await GenerateHashAndExposeDataToNetworkUsingPOSTAsyncWithHttpInfo(data, name, keywords, metadata);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Generates the encrypted datahash and uploads the JSON Format String data to the P2P Storage Network. This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network</param>
        /// <param name="name">Custom Name of the data. If none is specified, timestamp will be used. (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of ApiResponse (BinaryTransactionEncryptedMessage)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BinaryTransactionEncryptedMessage>> GenerateHashAndExposeDataToNetworkUsingPOSTAsyncWithHttpInfo (string data, string name = null, string keywords = null, string metadata = null)
        {
            // verify the required parameter 'data' is set
            if (data == null)
                throw new ApiException(400, "Missing required parameter 'data' when calling DataHashApi->GenerateHashAndExposeDataToNetworkUsingPOST");

            var localVarPath = "/datahash/upload/data/generate";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null) localVarQueryParams.Add("data", Configuration.ApiClient.ParameterToString(data)); // query parameter
            if (name != null) localVarQueryParams.Add("name", Configuration.ApiClient.ParameterToString(name)); // query parameter
            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashAndExposeDataToNetworkUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BinaryTransactionEncryptedMessage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (BinaryTransactionEncryptedMessage) Configuration.ApiClient.Deserialize(localVarResponse, typeof(BinaryTransactionEncryptedMessage)));
        }

        /// <summary>
        /// Generates the encrypted datahash and uploads the file in the process. This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>BinaryTransactionEncryptedMessage</returns>
        public BinaryTransactionEncryptedMessage GenerateHashAndExposeFileToNetworkUsingPOST (System.IO.Stream file, string keywords = null, string metadata = null)
        {
             ApiResponse<BinaryTransactionEncryptedMessage> localVarResponse = GenerateHashAndExposeFileToNetworkUsingPOSTWithHttpInfo(file, keywords, metadata);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Generates the encrypted datahash and uploads the file in the process. This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>ApiResponse of BinaryTransactionEncryptedMessage</returns>
        public ApiResponse< BinaryTransactionEncryptedMessage > GenerateHashAndExposeFileToNetworkUsingPOSTWithHttpInfo (System.IO.Stream file, string keywords = null, string metadata = null)
        {
            // verify the required parameter 'file' is set
            if (file == null)
                throw new ApiException(400, "Missing required parameter 'file' when calling DataHashApi->GenerateHashAndExposeFileToNetworkUsingPOST");

            var localVarPath = "/datahash/upload/generate";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter
            if (file != null) localVarFileParams.Add("file", Configuration.ApiClient.ParameterToFile("file", file));


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashAndExposeFileToNetworkUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BinaryTransactionEncryptedMessage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (BinaryTransactionEncryptedMessage) Configuration.ApiClient.Deserialize(localVarResponse, typeof(BinaryTransactionEncryptedMessage)));
        }

        /// <summary>
        /// Generates the encrypted datahash and uploads the file in the process. This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of BinaryTransactionEncryptedMessage</returns>
        public async System.Threading.Tasks.Task<BinaryTransactionEncryptedMessage> GenerateHashAndExposeFileToNetworkUsingPOSTAsync (System.IO.Stream file, string keywords = null, string metadata = null)
        {
             ApiResponse<BinaryTransactionEncryptedMessage> localVarResponse = await GenerateHashAndExposeFileToNetworkUsingPOSTAsyncWithHttpInfo(file, keywords, metadata);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Generates the encrypted datahash and uploads the file in the process. This endpoint can be used to generates the encrypted datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of ApiResponse (BinaryTransactionEncryptedMessage)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BinaryTransactionEncryptedMessage>> GenerateHashAndExposeFileToNetworkUsingPOSTAsyncWithHttpInfo (System.IO.Stream file, string keywords = null, string metadata = null)
        {
            // verify the required parameter 'file' is set
            if (file == null)
                throw new ApiException(400, "Missing required parameter 'file' when calling DataHashApi->GenerateHashAndExposeFileToNetworkUsingPOST");

            var localVarPath = "/datahash/upload/generate";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter
            if (file != null) localVarFileParams.Add("file", Configuration.ApiClient.ParameterToFile("file", file));


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashAndExposeFileToNetworkUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BinaryTransactionEncryptedMessage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (BinaryTransactionEncryptedMessage) Configuration.ApiClient.Deserialize(localVarResponse, typeof(BinaryTransactionEncryptedMessage)));
        }

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature. 
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>RequestAnnounceDataSignature</returns>
        public RequestAnnounceDataSignature GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOST (string xPvkey = null, string xPubkey = null, string messageType = null, string data = null, string keywords = null, string metadata = null)
        {
             ApiResponse<RequestAnnounceDataSignature> localVarResponse = GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOSTWithHttpInfo(xPvkey, xPubkey, messageType, data, keywords, metadata);
             return localVarResponse.Data;
        }

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature. 
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>ApiResponse of RequestAnnounceDataSignature</returns>
        public ApiResponse< RequestAnnounceDataSignature > GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOSTWithHttpInfo (string xPvkey = null, string xPubkey = null, string messageType = null, string data = null, string keywords = null, string metadata = null)
        {

            var localVarPath = "/datahash/upload/data/generate-sign";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (messageType != null) localVarQueryParams.Add("messageType", Configuration.ApiClient.ParameterToString(messageType)); // query parameter
            if (data != null) localVarQueryParams.Add("data", Configuration.ApiClient.ParameterToString(data)); // query parameter
            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter
            if (xPvkey != null) localVarHeaderParams.Add("x-pvkey", Configuration.ApiClient.ParameterToString(xPvkey)); // header parameter
            if (xPubkey != null) localVarHeaderParams.Add("x-pubkey", Configuration.ApiClient.ParameterToString(xPubkey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RequestAnnounceDataSignature>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RequestAnnounceDataSignature) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RequestAnnounceDataSignature)));
        }

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature. 
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>Task of RequestAnnounceDataSignature</returns>
        public async System.Threading.Tasks.Task<RequestAnnounceDataSignature> GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOSTAsync (string xPvkey = null, string xPubkey = null, string messageType = null, string data = null, string keywords = null, string metadata = null)
        {
             ApiResponse<RequestAnnounceDataSignature> localVarResponse = await GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOSTAsyncWithHttpInfo(xPvkey, xPubkey, messageType, data, keywords, metadata);
             return localVarResponse.Data;

        }

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature. 
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>Task of ApiResponse (RequestAnnounceDataSignature)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RequestAnnounceDataSignature>> GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOSTAsyncWithHttpInfo (string xPvkey = null, string xPubkey = null, string messageType = null, string data = null, string keywords = null, string metadata = null)
        {

            var localVarPath = "/datahash/upload/data/generate-sign";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (messageType != null) localVarQueryParams.Add("messageType", Configuration.ApiClient.ParameterToString(messageType)); // query parameter
            if (data != null) localVarQueryParams.Add("data", Configuration.ApiClient.ParameterToString(data)); // query parameter
            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter
            if (xPvkey != null) localVarHeaderParams.Add("x-pvkey", Configuration.ApiClient.ParameterToString(xPvkey)); // header parameter
            if (xPubkey != null) localVarHeaderParams.Add("x-pubkey", Configuration.ApiClient.ParameterToString(xPubkey)); // header parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashExposeByteArrayToNetworkBuildAndSignUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RequestAnnounceDataSignature>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RequestAnnounceDataSignature) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RequestAnnounceDataSignature)));
        }

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature. 
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="file">The Multipart File (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>RequestAnnounceDataSignature</returns>
        public RequestAnnounceDataSignature GenerateHashExposeFileToNetworkBuildAndSignUsingPOST (string xPvkey = null, string xPubkey = null, string messageType = null, System.IO.Stream file = null, string keywords = null, string metadata = null)
        {
             ApiResponse<RequestAnnounceDataSignature> localVarResponse = GenerateHashExposeFileToNetworkBuildAndSignUsingPOSTWithHttpInfo(xPvkey, xPubkey, messageType, file, keywords, metadata);
             return localVarResponse.Data;
        }

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature. 
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="file">The Multipart File (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>ApiResponse of RequestAnnounceDataSignature</returns>
        public ApiResponse< RequestAnnounceDataSignature > GenerateHashExposeFileToNetworkBuildAndSignUsingPOSTWithHttpInfo (string xPvkey = null, string xPubkey = null, string messageType = null, System.IO.Stream file = null, string keywords = null, string metadata = null)
        {

            var localVarPath = "/datahash/upload/generate-sign";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (messageType != null) localVarQueryParams.Add("messageType", Configuration.ApiClient.ParameterToString(messageType)); // query parameter
            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter
            if (xPvkey != null) localVarHeaderParams.Add("x-pvkey", Configuration.ApiClient.ParameterToString(xPvkey)); // header parameter
            if (xPubkey != null) localVarHeaderParams.Add("x-pubkey", Configuration.ApiClient.ParameterToString(xPubkey)); // header parameter
            if (file != null) localVarFileParams.Add("file", Configuration.ApiClient.ParameterToFile("file", file));


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashExposeFileToNetworkBuildAndSignUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RequestAnnounceDataSignature>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RequestAnnounceDataSignature) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RequestAnnounceDataSignature)));
        }

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature. 
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="file">The Multipart File (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>Task of RequestAnnounceDataSignature</returns>
        public async System.Threading.Tasks.Task<RequestAnnounceDataSignature> GenerateHashExposeFileToNetworkBuildAndSignUsingPOSTAsync (string xPvkey = null, string xPubkey = null, string messageType = null, System.IO.Stream file = null, string keywords = null, string metadata = null)
        {
             ApiResponse<RequestAnnounceDataSignature> localVarResponse = await GenerateHashExposeFileToNetworkBuildAndSignUsingPOSTAsyncWithHttpInfo(xPvkey, xPubkey, messageType, file, keywords, metadata);
             return localVarResponse.Data;

        }

        /// <summary>
        /// This endpoint can be used to generate the transaction along with the data hash with the private key signature. 
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="xPvkey">Sender Private Key (optional)</param>
        /// <param name="xPubkey">Receiver Public Key (optional)</param>
        /// <param name="messageType">Message Type ( PLAIN or SECURE ) (optional)</param>
        /// <param name="file">The Multipart File (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">Json Format Data Structure (optional)</param>
        /// <returns>Task of ApiResponse (RequestAnnounceDataSignature)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RequestAnnounceDataSignature>> GenerateHashExposeFileToNetworkBuildAndSignUsingPOSTAsyncWithHttpInfo (string xPvkey = null, string xPubkey = null, string messageType = null, System.IO.Stream file = null, string keywords = null, string metadata = null)
        {

            var localVarPath = "/datahash/upload/generate-sign";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (messageType != null) localVarQueryParams.Add("messageType", Configuration.ApiClient.ParameterToString(messageType)); // query parameter
            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter
            if (xPvkey != null) localVarHeaderParams.Add("x-pvkey", Configuration.ApiClient.ParameterToString(xPvkey)); // header parameter
            if (xPubkey != null) localVarHeaderParams.Add("x-pubkey", Configuration.ApiClient.ParameterToString(xPubkey)); // header parameter
            if (file != null) localVarFileParams.Add("file", Configuration.ApiClient.ParameterToFile("file", file));


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashExposeFileToNetworkBuildAndSignUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RequestAnnounceDataSignature>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RequestAnnounceDataSignature) Configuration.ApiClient.Deserialize(localVarResponse, typeof(RequestAnnounceDataSignature)));
        }

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file. This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>BinaryTransactionEncryptedMessage</returns>
        public BinaryTransactionEncryptedMessage GenerateHashForDataOnlyUsingPOST (string data = null, string keywords = null, string metadata = null)
        {
             ApiResponse<BinaryTransactionEncryptedMessage> localVarResponse = GenerateHashForDataOnlyUsingPOSTWithHttpInfo(data, keywords, metadata);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file. This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>ApiResponse of BinaryTransactionEncryptedMessage</returns>
        public ApiResponse< BinaryTransactionEncryptedMessage > GenerateHashForDataOnlyUsingPOSTWithHttpInfo (string data = null, string keywords = null, string metadata = null)
        {

            var localVarPath = "/datahash/generate/data/hashonly";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null) localVarQueryParams.Add("data", Configuration.ApiClient.ParameterToString(data)); // query parameter
            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashForDataOnlyUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BinaryTransactionEncryptedMessage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (BinaryTransactionEncryptedMessage) Configuration.ApiClient.Deserialize(localVarResponse, typeof(BinaryTransactionEncryptedMessage)));
        }

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file. This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of BinaryTransactionEncryptedMessage</returns>
        public async System.Threading.Tasks.Task<BinaryTransactionEncryptedMessage> GenerateHashForDataOnlyUsingPOSTAsync (string data = null, string keywords = null, string metadata = null)
        {
             ApiResponse<BinaryTransactionEncryptedMessage> localVarResponse = await GenerateHashForDataOnlyUsingPOSTAsyncWithHttpInfo(data, keywords, metadata);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file. This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="data">Free form string data that will be stored on the P2P Network (optional)</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of ApiResponse (BinaryTransactionEncryptedMessage)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BinaryTransactionEncryptedMessage>> GenerateHashForDataOnlyUsingPOSTAsyncWithHttpInfo (string data = null, string keywords = null, string metadata = null)
        {

            var localVarPath = "/datahash/generate/data/hashonly";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (data != null) localVarQueryParams.Add("data", Configuration.ApiClient.ParameterToString(data)); // query parameter
            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashForDataOnlyUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BinaryTransactionEncryptedMessage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (BinaryTransactionEncryptedMessage) Configuration.ApiClient.Deserialize(localVarResponse, typeof(BinaryTransactionEncryptedMessage)));
        }

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file. This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>BinaryTransactionEncryptedMessage</returns>
        public BinaryTransactionEncryptedMessage GenerateHashForFileOnlyUsingPOST (System.IO.Stream file, string keywords = null, string metadata = null)
        {
             ApiResponse<BinaryTransactionEncryptedMessage> localVarResponse = GenerateHashForFileOnlyUsingPOSTWithHttpInfo(file, keywords, metadata);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file. This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>ApiResponse of BinaryTransactionEncryptedMessage</returns>
        public ApiResponse< BinaryTransactionEncryptedMessage > GenerateHashForFileOnlyUsingPOSTWithHttpInfo (System.IO.Stream file, string keywords = null, string metadata = null)
        {
            // verify the required parameter 'file' is set
            if (file == null)
                throw new ApiException(400, "Missing required parameter 'file' when calling DataHashApi->GenerateHashForFileOnlyUsingPOST");

            var localVarPath = "/datahash/generate/hashonly";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter
            if (file != null) localVarFileParams.Add("file", Configuration.ApiClient.ParameterToFile("file", file));


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashForFileOnlyUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BinaryTransactionEncryptedMessage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (BinaryTransactionEncryptedMessage) Configuration.ApiClient.Deserialize(localVarResponse, typeof(BinaryTransactionEncryptedMessage)));
        }

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file. This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of BinaryTransactionEncryptedMessage</returns>
        public async System.Threading.Tasks.Task<BinaryTransactionEncryptedMessage> GenerateHashForFileOnlyUsingPOSTAsync (System.IO.Stream file, string keywords = null, string metadata = null)
        {
             ApiResponse<BinaryTransactionEncryptedMessage> localVarResponse = await GenerateHashForFileOnlyUsingPOSTAsyncWithHttpInfo(file, keywords, metadata);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Generates the datahash but doesn&#39;t upload the entire file. This endpoint can be used to generates the datahash and uploads the file in the process.
        /// </summary>
        /// <exception cref="Io.Xpx.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="file">The Multipart File that will be stored on the P2P Storage Network</param>
        /// <param name="keywords">Comma delimited Keyword/Tags (optional)</param>
        /// <param name="metadata">JSON Format MetaData stored on the NEM Txn Message (optional)</param>
        /// <returns>Task of ApiResponse (BinaryTransactionEncryptedMessage)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<BinaryTransactionEncryptedMessage>> GenerateHashForFileOnlyUsingPOSTAsyncWithHttpInfo (System.IO.Stream file, string keywords = null, string metadata = null)
        {
            // verify the required parameter 'file' is set
            if (file == null)
                throw new ApiException(400, "Missing required parameter 'file' when calling DataHashApi->GenerateHashForFileOnlyUsingPOST");

            var localVarPath = "/datahash/generate/hashonly";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (keywords != null) localVarQueryParams.Add("keywords", Configuration.ApiClient.ParameterToString(keywords)); // query parameter
            if (metadata != null) localVarQueryParams.Add("metadata", Configuration.ApiClient.ParameterToString(metadata)); // query parameter
            if (file != null) localVarFileParams.Add("file", Configuration.ApiClient.ParameterToFile("file", file));


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GenerateHashForFileOnlyUsingPOST", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<BinaryTransactionEncryptedMessage>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (BinaryTransactionEncryptedMessage) Configuration.ApiClient.Deserialize(localVarResponse, typeof(BinaryTransactionEncryptedMessage)));
        }

    }
}
